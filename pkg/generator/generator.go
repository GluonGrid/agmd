package generator

import (
	"fmt"
	"os"
	"strings"

	"agmd/pkg/parser"
	"agmd/pkg/registry"
	"agmd/pkg/state"
)

// Generator handles AGENTS.md generation from registry and state
type Generator struct {
	Registry *registry.Registry
	State    *state.ProjectState
}

// New creates a new Generator
func New(reg *registry.Registry, st *state.ProjectState) *Generator {
	return &Generator{
		Registry: reg,
		State:    st,
	}
}

// Generate creates the complete AGENTS.md content
func (g *Generator) Generate() (string, error) {
	var builder strings.Builder

	// Header
	builder.WriteString("# Agent Instructions\n\n")
	builder.WriteString("*Generated by agmd - https://github.com/GluonGrid/agmd*\n\n")

	// Managed section start
	builder.WriteString("<!-- agmd:managed-start -->\n")
	builder.WriteString("<!-- Auto-generated by agmd. Do not edit manually. -->\n\n")

	// Render rules
	if len(g.State.Rules) > 0 {
		builder.WriteString("## Rules\n\n")
		for _, ruleName := range g.State.Rules {
			content, err := g.renderRule(ruleName)
			if err != nil {
				return "", fmt.Errorf("failed to render rule '%s': %w", ruleName, err)
			}
			builder.WriteString(content)
			builder.WriteString("\n")
		}
	}

	// Render workflows
	if len(g.State.Workflows) > 0 {
		builder.WriteString("## Workflows\n\n")
		for _, workflowName := range g.State.Workflows {
			content, err := g.renderWorkflow(workflowName)
			if err != nil {
				return "", fmt.Errorf("failed to render workflow '%s': %w", workflowName, err)
			}
			builder.WriteString(content)
			builder.WriteString("\n")
		}
	}

	// Render guidelines
	if len(g.State.Guidelines) > 0 {
		builder.WriteString("## Guidelines\n\n")
		for _, guidelineName := range g.State.Guidelines {
			content, err := g.renderGuideline(guidelineName)
			if err != nil {
				return "", fmt.Errorf("failed to render guideline '%s': %w", guidelineName, err)
			}
			builder.WriteString(content)
			builder.WriteString("\n")
		}
	}

	// Managed section end
	builder.WriteString("<!-- agmd:managed-end -->\n\n")

	// Custom section (with default template)
	builder.WriteString("<!-- agmd:custom-start -->\n\n")
	builder.WriteString("## Project-Specific Notes\n\n")
	builder.WriteString("*Add your project-specific instructions, setup notes, or documentation here.*\n")
	builder.WriteString("*This section is preserved when regenerating AGENTS.md.*\n\n")
	builder.WriteString("<!-- agmd:custom-end -->\n")

	return builder.String(), nil
}

// GeneratePreservingCustom generates AGENTS.md while preserving existing custom content
func (g *Generator) GeneratePreservingCustom(existingPath string) (string, error) {
	// Read existing file if it exists
	existingContent, err := os.ReadFile(existingPath)
	var customSection string

	if err == nil {
		// Extract custom section
		customSection = extractCustomSection(string(existingContent))
	}

	// Generate new managed section
	var builder strings.Builder

	// Header
	builder.WriteString("# Agent Instructions\n\n")
	builder.WriteString("*Generated by agmd - https://github.com/GluonGrid/agmd*\n\n")

	// Managed section
	builder.WriteString("<!-- agmd:managed-start -->\n")
	builder.WriteString("<!-- Auto-generated by agmd. Do not edit manually. -->\n\n")

	// Render rules
	if len(g.State.Rules) > 0 {
		builder.WriteString("## Rules\n\n")
		for _, ruleName := range g.State.Rules {
			content, err := g.renderRule(ruleName)
			if err != nil {
				return "", fmt.Errorf("failed to render rule '%s': %w", ruleName, err)
			}
			builder.WriteString(content)
			builder.WriteString("\n")
		}
	}

	// Render workflows
	if len(g.State.Workflows) > 0 {
		builder.WriteString("## Workflows\n\n")
		for _, workflowName := range g.State.Workflows {
			content, err := g.renderWorkflow(workflowName)
			if err != nil {
				return "", fmt.Errorf("failed to render workflow '%s': %w", workflowName, err)
			}
			builder.WriteString(content)
			builder.WriteString("\n")
		}
	}

	// Render guidelines
	if len(g.State.Guidelines) > 0 {
		builder.WriteString("## Guidelines\n\n")
		for _, guidelineName := range g.State.Guidelines {
			content, err := g.renderGuideline(guidelineName)
			if err != nil {
				return "", fmt.Errorf("failed to render guideline '%s': %w", guidelineName, err)
			}
			builder.WriteString(content)
			builder.WriteString("\n")
		}
	}

	builder.WriteString("<!-- agmd:managed-end -->\n\n")

	// Add custom section (preserved or default)
	if customSection != "" {
		builder.WriteString(customSection)
	} else {
		// Default custom section
		builder.WriteString("<!-- agmd:custom-start -->\n\n")
		builder.WriteString("## Project-Specific Notes\n\n")
		builder.WriteString("*Add your project-specific instructions, setup notes, or documentation here.*\n")
		builder.WriteString("*This section is preserved when regenerating AGENTS.md.*\n\n")
		builder.WriteString("<!-- agmd:custom-end -->\n")
	}

	return builder.String(), nil
}

// renderRule renders a rule from the registry (strips frontmatter, keeps markdown)
func (g *Generator) renderRule(name string) (string, error) {
	rule, err := g.Registry.GetRule(name)
	if err != nil {
		return "", err
	}

	// Return content without frontmatter (it was already stripped by loader)
	return formatAsSubsection(rule.Name, rule.Content), nil
}

// renderWorkflow renders a workflow from the registry
func (g *Generator) renderWorkflow(name string) (string, error) {
	workflow, err := g.Registry.GetWorkflow(name)
	if err != nil {
		return "", err
	}

	return formatAsSubsection(workflow.Name, workflow.Content), nil
}

// renderGuideline renders a guideline from the registry
func (g *Generator) renderGuideline(name string) (string, error) {
	guideline, err := g.Registry.GetGuideline(name)
	if err != nil {
		return "", err
	}

	return formatAsSubsection(guideline.Name, guideline.Content), nil
}

// formatAsSubsection wraps content as a ### subsection
func formatAsSubsection(name, content string) string {
	var builder strings.Builder
	builder.WriteString(fmt.Sprintf("### %s\n\n", name))
	builder.WriteString(strings.TrimSpace(content))
	builder.WriteString("\n\n")
	return builder.String()
}

// ParseAndExpand reads AGENTS.md with directives, expands them from registry, and returns the result
// This is the new directive-based generation method that replaces the TOML-based approach
func (g *Generator) ParseAndExpand(inputPath string) (string, error) {
	// Read the AGENTS.md file (which contains directives)
	content, err := os.ReadFile(inputPath)
	if err != nil {
		return "", fmt.Errorf("failed to read %s: %w", inputPath, err)
	}

	// Use the parser to expand directives
	expanded, err := parser.ParseAndExpand(content, g.Registry.GetBasePath())
	if err != nil {
		return "", fmt.Errorf("failed to parse and expand directives: %w", err)
	}

	return string(expanded), nil
}
